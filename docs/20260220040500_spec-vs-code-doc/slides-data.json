{
	"slides": [
		{
			"title": "「仕様書文化」vs「コード is ドキュメント」",
			"layout": "center",
			"content": [
				"― 世代間・文化間の衝突を超えて ―",
				"",
				"テックリード・エンジニアリングマネージャー向け",
				"2026年"
			]
		},
		{
			"title": "アジェンダ",
			"layout": "default",
			"content": [
				"**Part 1** 両文化の誕生 — 定義と歴史的背景",
				"**Part 2** 仕様書文化の光と影",
				"**Part 3** コード is ドキュメント文化の光と影",
				"**Part 4** 世代間・文化間の衝突を解剖する",
				"**Part 5** 対立を超えて — 統合的アプローチ",
				"**Part 6** テックリード・EM のための実践ガイド"
			]
		},
		{
			"title": "Part 1: 両文化の誕生",
			"layout": "section",
			"content": ["定義と歴史的背景"]
		},
		{
			"title": "「仕様書文化」の世界観",
			"layout": "default",
			"content": [
				"**定義**: コードを書く前に要件・設計を文書化し、それを正として開発を進める文化",
				"",
				"**中心にある価値観:**",
				"- 合意の証跡: 「書いてあること」が真実",
				"- 先行設計: 動く前にすべてを決める",
				"- 責任の明確化: 仕様通りに作ったか否か",
				"",
				"**典型的な成果物:**",
				"- 要件定義書・外部設計書・内部設計書",
				"- ER図・シーケンス図・テスト仕様書"
			]
		},
		{
			"title": "「コード is ドキュメント」の世界観",
			"layout": "default",
			"content": [
				"**定義**: コード自体が最も正確なドキュメントであり、別途文書を最小化する文化",
				"",
				"**中心にある価値観:**",
				"- 単一の真実: コードは嘘をつかない",
				"- 自己文書化: 読めばわかるコードを書く",
				"- ドキュメントは負債: メンテされない仕様書は害悪",
				"",
				"**典型的な実践:**",
				"- 関数名・型・テストコードが仕様",
				"- README と inline comment のみ",
				"- コードレビューで意図を伝える"
			]
		},
		{
			"title": "歴史的背景 — 2つの文化が生まれた理由",
			"layout": "default",
			"content": ["![w:860 center](assets/history-timeline.svg)"]
		},
		{
			"title": "なぜ今、対立が激化しているのか",
			"layout": "default",
			"content": [
				"**3つの構造変化が「価値観の衝突」を表面化させた**",
				"",
				"**① リモート・グローバル化**",
				"- 暗黙知が通じない。文脈が共有されない",
				"- 時差・言語の壁で「口頭で補う」が不可能に",
				"",
				"**② 世代交代の加速**",
				"- 「ウォーターフォール世代」とアジャイルネイティブの共存",
				"- キャリアパス・評価基準の違い",
				"",
				"**③ AI コーディングツールの普及**",
				"- コードは書けるが、WHY は生成されない",
				"- 「コードが増えるほどドキュメントが消える」逆説"
			]
		},
		{
			"title": "Part 2: 仕様書文化の光と影",
			"layout": "section",
			"content": ["正しく機能する場面と崩壊する場面"]
		},
		{
			"title": "仕様書が真価を発揮する場面",
			"layout": "default",
			"content": [
				"**仕様書が本当に必要なケース:**",
				"",
				"- **法的・コンプライアンス要件** — 金融・医療・官公庁",
				"  - 変更のたびに承認が必要。監査証跡が必須",
				"- **外部委託・オフショア開発**",
				"  - 同じ場所にいない、言語が違う、文化が違う",
				"  - 「言った言わない」をなくす唯一の手段",
				"- **長期保守・引き継ぎ**",
				"  - 10年後に誰かが読む。コードだけでは足りない",
				"- **複数ベンダー間の契約境界**",
				"  - API 仕様書がないと責任分界が曖昧になる"
			]
		},
		{
			"title": "日本の現場: SIer・官公庁の仕様書文化",
			"layout": "default",
			"content": [
				"**なぜ日本に「仕様書文化」が根付いたか:**",
				"",
				"- **体制**: 発注者 → 元請け → 下請け → 孫請けの多層構造",
				"  - 各レイヤーで「証拠」が必要",
				"- **責任文化**: 問題が起きたとき「仕様通りに作った」が免責の根拠",
				"- **変更管理の硬直性**: 仕様変更は正式な変更管理プロセスが必要",
				"- **成果物主義**: 納品物 = 設計書 + ソースコード + テスト証跡",
				"",
				"**現代での弊害:**",
				"- 仕様書作成コストがエンジニアリング時間の 30〜50% を占めることも",
				"- ドキュメントのために機能実装が後回しになる"
			]
		},
		{
			"title": "ドキュメントの腐敗サイクル",
			"layout": "default",
			"content": ["![w:860 center](assets/doc-decay-cycle.svg)"]
		},
		{
			"title": "「書いたけど誰も読まない」症候群",
			"layout": "default",
			"content": [
				"**なぜドキュメントは読まれないのか:**",
				"",
				"- **発見できない**: どこにあるか誰も知らない",
				"- **最新かわからない**: 更新日時が半年前",
				"- **長すぎる**: 読む気が起きない 200ページの設計書",
				"- **コードと乖離している**: 動かしてみると違う",
				"",
				"**心理的メカニズム:**",
				"- 作る人と使う人が違う → ゴール設定がズレる",
				"- 「書いた」で満足 → 「読まれる」までが仕事だという認識がない",
				"- 義務で書く → 最低限しか書かない"
			]
		},
		{
			"title": "Part 3: コード is ドキュメント文化の光と影",
			"layout": "section",
			"content": ["哲学の正しさと現実の落とし穴"]
		},
		{
			"title": "自己文書化コードの哲学",
			"layout": "default",
			"content": [
				"**Clean Code (Robert C. Martin) の核心:**",
				"- 「コードで意図を表現せよ。コメントはコードの失敗を補うもの」",
				"",
				"**自己文書化の3原則:**",
				"- **命名**: 変数・関数・クラス名で意図を完全表現",
				"  - `getUserByEmail()` > `get()` > `func1()`",
				"- **型**: 型システムが仕様を強制する",
				"  - `UserId` (型エイリアス) > `string`",
				"- **テスト**: テストコードが動く仕様書",
				"  - `should_reject_expired_token()` は仕様そのもの",
				"",
				"**正しい前提条件**: 同じコードベースに長く関わるメンバーがいる場合"
			]
		},
		{
			"title": "コード例: 良い自己文書化 vs 悪い例",
			"layout": "default",
			"content": ["**悪い例 (What しか伝わらない):**"],
			"code": "// NG: コメントが何も説明していない\nfunction calc(u: User, d: Date): number {\n  // calculate\n  const days = diffDays(u.trialStart, d);\n  return days > 14 ? u.plan.price : 0;\n}\n\n// OK: 命名で意図を表現\nfunction calculateBillingAmount(\n  user: User,\n  billingDate: Date\n): Money {\n  const trialPeriodDays = 14;\n  const isInTrialPeriod =\n    daysBetween(user.trialStartDate, billingDate)\n    <= trialPeriodDays;\n  return isInTrialPeriod ? Money.zero() : user.plan.monthlyFee;\n}",
			"codeLanguage": "typescript"
		},
		{
			"title": "「型で全部わかる」という過信",
			"layout": "default",
			"content": [
				"**コードが表現できないもの:**",
				"",
				"- **なぜその設計にしたか (WHY)**",
				"  - 「なぜ PostgreSQL を使ったか」はコードにない",
				"  - 「なぜこのアルゴリズムを選んだか」も同様",
				"- **捨てた選択肢**",
				"  - 試みた別のアプローチとその失敗理由",
				"- **ビジネスコンテキスト**",
				"  - 「この仕様は法律 X 条に基づく」という背景",
				"- **非自明なトレードオフ**",
				"  - 「パフォーマンスより可読性を優先した理由」",
				"",
				"**結果:** 新メンバーがコードを読んでも「なぜそうなっているか」がわからない"
			]
		},
		{
			"title": "引き継ぎ・オンボーディングで崩壊するとき",
			"layout": "default",
			"content": [
				"**典型的なシナリオ:**",
				"",
				"- キーエンジニアが退職。コードしか残っていない",
				"- 「コードを読めばわかる」 → 読んでもわからない",
				"- 暗黙のルール・設計上の制約が頭の中だけに",
				"",
				"**コード is ドキュメントが失敗する条件:**",
				"",
				"| 状況 | リスク |",
				"|------|-------|",
				"| 属人化したコードベース | 「書いた本人しか読めない」 |",
				"| 急速に成長するチーム | オンボーディングコストが爆発 |",
				"| マイクロサービス境界 | サービス間のコンテキストが消える |",
				"| AI 生成コードの増加 | WHY が一切ない大量のコード |"
			]
		},
		{
			"title": "Part 4: 世代間・文化間の衝突",
			"layout": "section",
			"content": ["対立の構造を解剖する"]
		},
		{
			"title": "世代別: ドキュメントへの価値観マップ",
			"layout": "default",
			"content": ["![w:860 center](assets/generation-map.svg)"]
		},
		{
			"title": "日本 vs 欧米: 文化的背景の違い",
			"layout": "default",
			"content": [
				"**ハイコンテキスト文化 (日本) vs ローコンテキスト文化 (欧米):**",
				"",
				"| 観点 | 日本 (ハイコンテキスト) | 欧米 (ローコンテキスト) |",
				"|------|----------------------|----------------------|",
				"| コミュニケーション | 行間・空気を読む | 明文化・直接表現 |",
				"| ドキュメント観 | 書かなくても通じる | 書かないと存在しない |",
				"| 合意形成 | 根回し・阿吽の呼吸 | ミーティング + 議事録 |",
				"| 責任の所在 | 曖昧・全員で共有 | 個人・役割で明確 |",
				"",
				"**グローバルチームでの衝突の本質:**",
				"- 日本側: 「空気を読んでくれ」",
				"- 海外側: 「書いてないことは決まっていない」"
			]
		},
		{
			"title": "オフショア開発における仕様書の役割",
			"layout": "default",
			"content": [
				"**なぜオフショアで仕様書が必須になるか:**",
				"",
				"- **言語バリア**: 英語 or 現地語の詳細仕様書がないと意図が伝わらない",
				"- **時差**: リアルタイムの確認ができない。非同期が前提",
				"- **文化バリア**: 「察する」ができない",
				"- **契約関係**: スコープ定義がないと追加費用の根拠が曖昧",
				"",
				"**実際の問題:**",
				"- 仕様書を「あとで書く」文化の会社がオフショアを始めると即座に破綻",
				"- 「コードで確認して」は通じない",
				"",
				"**解決策の方向性:**",
				"- OpenAPI / Protobuf 定義が「実行可能な仕様書」として機能",
				"- 自動生成ドキュメントで腐敗を防ぐ"
			]
		},
		{
			"title": "「エビデンス」vs「動くコード」",
			"layout": "default",
			"content": [
				"**同じ作業、まったく違う価値基準:**",
				"",
				"- **仕様書文化**: 成果物 = 設計書・テスト証跡・議事録",
				"  - 「ドキュメントが揃っていれば仕事は完了」",
				"  - 「バグが出ても仕様通りなら問題ない」",
				"",
				"- **コード is ドキュメント**: 成果物 = 動くソフトウェア",
				"  - 「ドキュメントより先にデモを見せる」",
				"  - 「動かなければ存在しないのと同じ」",
				"",
				"**マネジメント層での衝突:**",
				"- PM: 「なぜ仕様書がないのか」",
				"- エンジニア: 「コードとテストが仕様書です」",
				"- PM: 「承認フローに通せない」"
			]
		},
		{
			"title": "事例: リモートチームで起きた混乱",
			"layout": "default",
			"content": [
				"**実際によくある状況 (複合ケース):**",
				"",
				"**背景**: 日本チーム (仕様書文化) ＋ 海外チーム (アジャイル) の協業",
				"",
				"**起きたこと:**",
				"- 日本チームが 50ページの仕様書を送付",
				"- 海外チームが「古いから参考程度に」とコードを先行実装",
				"- 日本チームが「仕様書と違う」と差し戻し",
				"- 海外チームが「仕様書に書いてあることは現実的じゃない」と反発",
				"",
				"**根本原因:**",
				"- どの粒度のドキュメントが「合意の場」かが共有されていなかった",
				"- 「仕様書 = 設計完了」vs「仕様書 = 叩き台」という認識の違い"
			]
		},
		{
			"title": "Part 5: 対立を超えて — 統合的アプローチ",
			"layout": "section",
			"content": ["問いを立て直す"]
		},
		{
			"title": "本当の問題: ドキュメントの「目的」が定義されていない",
			"layout": "default",
			"content": [
				"**対立の根本にある「問いの立て方の誤り」:**",
				"",
				"❌ 「仕様書を書くべきか、書かないべきか」",
				"✅ 「誰が・いつ・何のために読むドキュメントか」",
				"",
				"**ドキュメントには複数の目的がある:**",
				"",
				"- **学習**: 初めて触れる人がシステムを理解する",
				"- **参照**: 実装中に詳細を確認する",
				"- **説明**: なぜその決定をしたか残す",
				"- **手順**: 具体的な操作手順を再現する",
				"",
				"**目的が違えば、最適な形式も違う。**",
				"\"仕様書\"という単語で全部を括るから議論が噛み合わない"
			]
		},
		{
			"title": "Divio ドキュメント4分類",
			"layout": "default",
			"content": ["![w:860 center](assets/divio-quadrant.svg)"]
		},
		{
			"title": "Architecture Decision Records (ADR)",
			"layout": "default",
			"content": [
				"**ADR = コードが表現できない「WHY」を残す最小限の実践**",
				"",
				"**形式 (Michael Nygard の提案):**"
			],
			"code": "# ADR-0042: PostgreSQL を主データベースとして採用\n\n## Status\nAccepted (2025-03-01)\n\n## Context\n- 複雑なリレーショナルクエリが必要\n- JSONB による柔軟なスキーマも必要\n- チームに MySQL の知見はあるが PG 経験者も複数いる\n\n## Decision\nPostgreSQL 17 を採用する\n\n## Consequences\n- (+) JSONB と RDB の両立が可能\n- (+) 豊富な拡張 (pgvector など) が使える\n- (-) MySQL との差異でハマるリスクがある",
			"codeLanguage": "markdown"
		},
		{
			"title": "Living Documentation と Executable Spec",
			"layout": "default",
			"content": [
				"**コードとドキュメントを分離しない実践:**",
				"",
				"**Living Documentation:**",
				"- コードから自動生成されるドキュメント",
				"- OpenAPI / GraphQL Schema → API ドキュメント自動生成",
				"- JavaDoc / TSDoc → 型定義からリファレンス生成",
				"- 「腐らない」: コードが変わればドキュメントも変わる",
				"",
				"**Executable Specification (BDD):**",
				"- Gherkin / Cucumber: 自然言語で書いたシナリオがテストになる",
				"- 「仕様書が動く」: 失敗したらドキュメントが壊れたことがわかる",
				"",
				"**実践のコツ:**",
				"- ドキュメントを CI でチェック → 壊れたら PR がマージできない"
			]
		},
		{
			"title": "チームのドキュメント戦略設計",
			"layout": "default",
			"content": ["![w:860 center](assets/doc-strategy.svg)"]
		},
		{
			"title": "ドキュメント負債の可視化と返済",
			"layout": "default",
			"content": [
				"**ドキュメントを「技術的負債」と同じフレームで扱う:**",
				"",
				"**負債の種類:**",
				"- **腐敗ドキュメント**: 内容が現状と乖離している",
				"- **欠落ドキュメント**: 重要な WHY が残っていない",
				"- **過剰ドキュメント**: メンテコストが価値を超えている",
				"",
				"**返済の優先順位:**",
				"1. アーキテクチャ判断 (ADR) — チーム全員が影響を受ける",
				"2. オンボーディングガイド — 採用コストに直結",
				"3. API リファレンス — 自動生成で返済コスト最小",
				"",
				"**定量化のヒント:**",
				"- 「新メンバーが最初の PR を出すまでの日数」を計測",
				"- 「同じ質問が Slack で何回聞かれたか」をカウント"
			]
		},
		{
			"title": "Part 6: テックリード・EM のための実践ガイド",
			"layout": "section",
			"content": ["今日から使えるアクション"]
		},
		{
			"title": "今週からできること (テックリード向け)",
			"layout": "default",
			"content": [
				"**即日: コードレビューの基準を変える**",
				"- 「なぜこの実装にしたか」を PR description に必須化",
				"- 型・テスト・コメントの「WHY」を指摘する習慣",
				"",
				"**今週: ADR を1枚書く**",
				"- 直近の大きな技術判断を ADR フォーマットで残す",
				"- `docs/adr/` ディレクトリを作ってコミット",
				"",
				"**今月: ドキュメント棚卸し**",
				"- 現存するドキュメントを Divio 4分類でラベリング",
				"- 腐敗・欠落・過剰を可視化してチームに共有",
				"",
				"**今四半期: Living Doc パイプライン**",
				"- OpenAPI / TSDoc の CI 自動生成を1つ実装"
			]
		},
		{
			"title": "文化の橋渡し: 合意形成の進め方",
			"layout": "default",
			"content": [
				"**「仕様書派」vs「コード派」の議論を建設的にする:**",
				"",
				"**Step 1: 用語を定義する**",
				"- 「ドキュメント」が指すものを全員で揃える",
				"- 「仕様書」= API 定義書なのか、設計書なのか、ADR なのか",
				"",
				"**Step 2: 目的から合意する**",
				"- 「誰がいつ読む？」を先に決めると選択肢が絞れる",
				"",
				"**Step 3: 段階的に導入**",
				"- まず ADR 1枚から始める (低コスト・高効果)",
				"- 全部一気に変えようとしない",
				"",
				"**Step 4: 成功事例を見せる**",
				"- 「ADR があって助かった」実例をチームに共有",
				"- 数字で効果を示す (オンボーディング日数の短縮など)"
			]
		},
		{
			"title": "ツール選定ガイド",
			"layout": "default",
			"content": [
				"**ドキュメントの種類 × 更新頻度で選ぶ:**",
				"",
				"| ドキュメント種別 | 推奨ツール | 理由 |",
				"|----------------|-----------|------|",
				"| ADR (設計判断) | GitHub Markdown | コードと同じ場所・PR で議論 |",
				"| API リファレンス | OpenAPI + Redoc | 自動生成・常に最新 |",
				"| チュートリアル | Notion / Confluence | 非エンジニアも編集しやすい |",
				"| 手順書 (runbook) | GitHub Wiki | エンジニアが更新しやすい |",
				"| アーキテクチャ図 | Mermaid + コミット | バージョン管理できる |",
				"",
				"**避けるべきパターン:**",
				"- 全部 Confluence / Notion → 更新が止まり検索性が落ちる",
				"- 全部コードコメント → 長大化して読まれなくなる"
			]
		},
		{
			"title": "ドキュメント文化 成熟度モデル",
			"layout": "default",
			"content": ["![w:860 center](assets/maturity-model.svg)"]
		},
		{
			"title": "まとめ: 「どちらが正しい」は問い方が間違い",
			"layout": "default",
			"content": [
				"**3つの核心:**",
				"",
				"**① 対立の本質は「目的の不一致」**",
				"- 仕様書派もコード派も「チームが動けること」を目指している",
				"- 違うのは「何が証拠になるか」という前提",
				"",
				"**② 文脈によって最適解は変わる**",
				"- オフショア・コンプライアンス → 仕様書が必要",
				"- 小規模・同室チーム → コード＋ADR で十分",
				"- どちらも「絶対正義」はない",
				"",
				"**③ テックリード・EM の役割**",
				"- 「どちらが正しいか」を仲裁するのではなく",
				"- 「誰が・いつ・何のために読むか」を問い続けること",
				"- 文化を強制するより、目的から合意形成する"
			]
		},
		{
			"title": "参考文献・リソース (1/2)",
			"layout": "default",
			"content": [
				"**書籍:**",
				"- [Clean Code — Robert C. Martin](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)",
				"- [A Philosophy of Software Design — John Ousterhout](https://web.stanford.edu/~ouster/cgi-bin/book.php)",
				"- [Living Documentation — Cyrille Martraire](https://www.pearson.com/en-us/subject-catalog/p/living-documentation/P200000009483)",
				"",
				"**記事・仕様:**",
				"- [Divio Documentation System](https://docs.divio.com/documentation-system/)",
				"- [ADR GitHub — Michael Nygard](https://github.com/joelparkerhenderson/architecture-decision-record)",
				"- [Architecture Haiku — Simon Brown](https://simonbrown.je/)",
				"- [The Majestic Monolith — DHH (2016)](https://signalvnoise.com/svn3/the-majestic-monolith/)"
			]
		},
		{
			"title": "参考文献・リソース (2/2)",
			"layout": "default",
			"content": [
				"**ツール・実践:**",
				"- [OpenAPI Specification](https://swagger.io/specification/)",
				"- [Cucumber / BDD (Executable Specification)](https://cucumber.io/)",
				"- [arc42 — Architecture Documentation](https://arc42.org/)",
				"- [Backstage — Developer Portal (Spotify)](https://backstage.io/)",
				"",
				"**日本語リソース:**",
				"- [ドキュメント駆動開発 — Qiita まとめ](https://qiita.com/tags/ドキュメント駆動開発)",
				"- [ADR を日本語チームに導入した話 — various tech blogs](https://zenn.dev/topics/adr)",
				"- [DX白書 2023 — IPA](https://www.ipa.go.jp/publish/wp-dx/)"
			]
		}
	]
}
