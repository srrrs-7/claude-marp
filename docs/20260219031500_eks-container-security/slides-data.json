{
	"slides": [
		{
			"title": "EKS / コンテナセキュリティ完全ガイド",
			"content": [
				"AWS認定試験対応 — DevOps Professional / Security Specialty",
				"RBAC・イメージスキャン・Fargate・ランタイム監視",
				"ultrathink: 実践的コマンド例・設定例・試験頻出ポイントを網羅",
				"120スライド構成 / 2026年版 SCS-C02 / DOP-C02 対応"
			],
			"layout": "center"
		},
		{
			"title": "アジェンダ (1/2) — 章構成",
			"content": [
				"**Ch.1** はじめに・EKSセキュリティ全体像 (8枚)",
				"**Ch.2** EKSアーキテクチャとセキュリティ基盤 (10枚)",
				"**Ch.3** RBAC・認証・認可 (22枚)",
				"**Ch.4** イメージセキュリティ・ECR (18枚)",
				"**Ch.5** Fargateセキュリティ (14枚)"
			],
			"layout": "default"
		},
		{
			"title": "アジェンダ (2/2) — 章構成",
			"content": [
				"**Ch.6** ネットワークセキュリティ (16枚)",
				"**Ch.7** Pod・ワークロードセキュリティ (12枚)",
				"**Ch.8** ランタイム監視・監査 (12枚)",
				"**Ch.9** 試験対策・頻出パターン・まとめ (8枚)",
				"→ 合計 **120枚** / DevOps Pro + Security Specialty 対応"
			],
			"layout": "default"
		},
		{
			"title": "なぜコンテナセキュリティが重要か",
			"content": [
				"**攻撃面の拡大**: コンテナイメージ・オーケストレーター・ネットワークが新たな攻撃ベクター",
				"**速度 vs セキュリティ**: CI/CDの高速化で脆弱なイメージが本番に到達するリスク",
				"**共有カーネル**: コンテナはVM と異なりホストカーネルを共有 → エスケープリスク",
				"**設定ミスが主因**: RBAC過剰権限・PublicイメージのLatestタグが侵害の入口",
				"**試験出題率**: SCS-C02 Domain3(20%) + Domain4(16%) = 約36% がコンテナ関連"
			],
			"layout": "default"
		},
		{
			"title": "試験ドメインとEKSセキュリティのカバレッジ",
			"content": [
				"**SCS-C02**: Domain3 インフラセキュリティ(20%) ← EKS Network, Fargate, WAF",
				"**SCS-C02**: Domain4 IAM(16%) ← RBAC, IRSA, Pod Identity, aws-auth",
				"**SCS-C02**: Domain2 ログ・監視(18%) ← GuardDuty EKS, CloudTrail, Falco",
				"**DOP-C02**: Domain1 SDLC自動化(22%) ← ECRスキャン, OPA, CI/CDパイプライン",
				"**DOP-C02**: Domain4 モニタリング(15%) ← Container Insights, EKS Audit Logs",
				"→ 本資料は両試験に横断的に対応"
			],
			"layout": "default"
		},
		{
			"title": "EKS 責任共有モデル",
			"content": [
				"**AWSが管理**: EKSコントロールプレーン（etcd, API Server, スケジューラー）",
				"**AWSが管理**: Fargateマイクロvm・ノードのOSパッチ（Fargateの場合のみ）",
				"**ユーザー責任**: EKS Data Plane（EC2ノードのOS, kubelet, ランタイム）",
				"**ユーザー責任**: RBAC設定・Pod Security・NetworkPolicy・Secrets管理",
				"**ユーザー責任**: コンテナイメージのセキュリティ・脆弱性管理",
				"**試験TIP**: 「誰が何を管理するか」で回答が決まる設問が頻出"
			],
			"layout": "default"
		},
		{
			"title": "EKS セキュリティレイヤー全体図",
			"content": ["![w:880 center](assets/eks-security-layers.svg)"],
			"layout": "default"
		},
		{
			"title": "前提知識・本資料の読み方",
			"content": [
				"**前提知識**: Kubernetes基礎（Pod, Deployment, Service, Namespace）",
				"**前提知識**: AWS基礎（IAM, VPC, S3, EC2, ECS）",
				"**本資料の読み方**: 各章末に試験頻出ポイントを集約",
				"**コードブロック**: コピーして実際に動かすことを推奨",
				"**SVG図解**: 各レイヤーの関係性を視覚的に把握",
				"→ `kubectl`, `eksctl`, `aws cli v2` のインストールを事前に推奨"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 2: EKSアーキテクチャとセキュリティ基盤",
			"content": [
				"EKSの構造を理解することがセキュリティ設計の基本",
				"コントロールプレーン・データプレーン・ネットワークの関係性を把握する"
			],
			"layout": "section"
		},
		{
			"title": "EKS コントロールプレーンとデータプレーン",
			"content": [
				"**コントロールプレーン（AWS管理）**: API Server, etcd, Scheduler, Controller Manager",
				"**データプレーン（ユーザー管理）**: EC2ノード or Fargate Pod",
				"**通信経路**: kubectl → EKS API Endpoint → Kubernetes API → ノード上のkubelet",
				"**etcd暗号化**: EKS etcdはAES-256で自動暗号化（KMS使用）",
				"**Kubernetes Secrets**: etcd暗号化はされているが、KMS Envelope暗号化を追加推奨",
				"→ `aws eks describe-cluster --name <cluster>` で暗号化設定確認"
			],
			"layout": "default"
		},
		{
			"title": "VPC設計とEKS統合",
			"content": [
				"**推奨VPC構成**: パブリックSubnet（NAT GW, ALB）+ プライベートSubnet（Node, Pod）",
				"**EKS用Subnet タグ**: `kubernetes.io/cluster/<name>=owned` が必須",
				"**最低限**: 各AZに1つのSubnet（高可用性のため2-3 AZ推奨）",
				"**VPC CNI制約**: Podにはノード同サブネットのIPが割り当てられる → 十分なIP空間が必要",
				"**CIDR設計**: `/16` VPC + `/24` Subnetで最大251 Pod/Subnet",
				"→ 大規模クラスターでは `/19` 以上のSubnetを推奨"
			],
			"layout": "default"
		},
		{
			"title": "EKS APIエンドポイントのアクセス制御",
			"content": [
				"**publicAccess + privateAccess（デフォルト）**: 外部からkubectl可能（CIDR制限推奨）",
				"**privateAccess のみ（推奨）**: VPC内のみ接続可能 → Bastion / VPN 経由",
				"**publicAccessCidrs**: 特定IPのみ許可（例: `[\"203.0.113.0/24\"]`）",
				"**試験TIP**: プライベートエンドポイントのみ設定 → kubectl実行にはVPC内踏み台が必要",
				"→ 侵害時のブラストラジウスを最小化するためプライベートエンドポイント推奨"
			],
			"code": "# エンドポイントをプライベートのみに変更\naws eks update-cluster-config \\\n  --name my-cluster \\\n  --resources-vpc-config \\\n    endpointPublicAccess=false,\\\n    endpointPrivateAccess=true",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "マネージドノードグループ vs Fargate",
			"content": [
				"**マネージドノードグループ**: EC2インスタンス、DaemonSet対応、GPU対応、OS管理必要",
				"**Fargate**: サーバーレス、OSパッチ不要、1Pod=1マイクロVM、DaemonSet不可",
				"**Fargateの制約**: privileged不可、hostNetwork不可、hostPID不可",
				"**使い分け**: ステートレスWebアプリ→Fargate、DaemonSet必要→マネージドノード",
				"**試験TIP**: 「ノード管理を排除」「OSパッチ自動化」→ Fargateが正解"
			],
			"layout": "default"
		},
		{
			"title": "クラスター作成のセキュリティ設定",
			"content": ["eksctlを使った最小権限・セキュアなクラスター作成の例"],
			"code": "# eksctl cluster config (secure)\napiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\nmetadata:\n  name: secure-cluster\n  region: ap-northeast-1\nvpc:\n  clusterEndpoints:\n    privateAccess: true\n    publicAccess: false\nsecretsEncryption:\n  keyARN: arn:aws:kms:...\nmanagedNodeGroups:\n  - name: ng-1\n    instanceType: m5.large\n    privateNetworking: true",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "EKS バージョン管理とパッチ戦略",
			"content": [
				"**EKSサポートサイクル**: 各バージョンのサポート期間は約14ヶ月",
				"**Extended Support**: サポート終了後さらに12ヶ月（有料）",
				"**アップグレード手順**: コントロールプレーン → マネージドノードグループ → Add-ons",
				"**試験TIP**: EKSバージョンは最大2バージョンまでアップグレード可能（スキップ不可）",
				"→ `aws eks update-cluster-version --name <cluster> --kubernetes-version 1.29`"
			],
			"layout": "default"
		},
		{
			"title": "CIS EKS Benchmark 入門",
			"content": [
				"**CIS EKS Benchmark**: Center for Internet Securityによるセキュリティ基準",
				"**カテゴリ**: 設定ファイル・認証・ポリシー・ログ・ネットワークを網羅",
				"**自動チェックツール**: `kube-bench`（CIS Benchmarkの自動評価）",
				"**PASS/WARN/FAIL**: 各チェック項目に対してスコアリング",
				"**AWS準拠**: EKSはデフォルトでCIS Level 1の多くに準拠している",
				"→ `kubectl apply -f job.yaml` でkube-benchをPodとして実行"
			],
			"layout": "default"
		},
		{
			"title": "セキュリティグループの設計原則",
			"content": [
				"**クラスターSG**: コントロールプレーン↔ノード間通信用（EKSが自動作成）",
				"**ノードSG**: ノード間Pod通信・ノードポート用",
				"**追加ルールの原則**: 最小権限（deny all + 必要なポートのみ許可）",
				"**443ポート**: ノード → API Server（絶対に必要）",
				"**10250ポート**: API Server → kubelet（ログ取得・exec用）",
				"**試験TIP**: EKSはクラスターSGを自動管理 → 手動で削除するとクラスター破損"
			],
			"layout": "default"
		},
		{
			"title": "EKS Add-ons セキュリティ設定",
			"content": [
				"**VPC CNI (aws-node)**: PodへのVPC IPアドレス割り当て。IRSA設定が必要",
				"**CoreDNS**: クラスター内DNS。外部フォワード先を制限推奨",
				"**kube-proxy**: ノード上でのネットワークルール管理",
				"**EBS CSI Driver**: PersistentVolumeのEBS接続（IRSA権限設定必須）",
				"**Add-onのIRSA**: 各Add-onに適切なIAMロールを付与して最小権限を実現",
				"→ `aws eks update-addon --service-account-role-arn <arn>` で後から設定可能"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 3: RBAC・認証・認可",
			"content": [
				"EKSにおける認証（誰か？）と認可（何ができるか？）の完全解説",
				"IAMとKubernetes RBACを組み合わせた最小権限設計"
			],
			"layout": "section"
		},
		{
			"title": "Kubernetes 認証フロー（EKS版）",
			"content": [
				"**Step 1**: kubectl実行 → AWS CLI で IAM認証情報を取得",
				"**Step 2**: `aws eks get-token` で短期Bearer Token生成（15分有効）",
				"**Step 3**: API Serverがトークンを検証（AWS IAM Authenticator）",
				"**Step 4**: aws-auth ConfigMapでIAMプリンシパル → K8s ユーザー/グループに変換",
				"**Step 5**: RBAC（Role/ClusterRole）で操作を認可",
				"→ IAM認証 ≠ Kubernetes認可（二段階で独立している）"
			],
			"layout": "default"
		},
		{
			"title": "aws-auth ConfigMap の仕組み",
			"content": [
				"**役割**: IAMプリンシパル（ユーザー/ロール）をK8sユーザー/グループにマッピング",
				"**格納場所**: `kube-system` Namespace の ConfigMap",
				"**mapRoles**: IAMロール → K8s グループ（ノード・CI/CD等）",
				"**mapUsers**: IAMユーザー → K8s ユーザー（個人開発者等）",
				"**デフォルト**: クラスター作成者のIAMエンティティは自動でcluster-admin",
				"**試験TIP**: aws-auth ConfigMapを間違えると全員がアクセス不可になる危険あり"
			],
			"layout": "default"
		},
		{
			"title": "aws-auth ConfigMap 設定例",
			"content": ["IAMロールをK8s グループにマッピングする設定"],
			"code": "# kubectl edit configmap aws-auth -n kube-system\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aws-auth\n  namespace: kube-system\ndata:\n  mapRoles: |\n    - rolearn: arn:aws:iam::123:role/EKSNodeRole\n      username: system:node:{{EC2PrivateDNSName}}\n      groups:\n        - system:bootstrappers\n        - system:nodes\n    - rolearn: arn:aws:iam::123:role/DevOpsRole\n      username: devops-user\n      groups:\n        - developers",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Kubernetes RBAC 概要",
			"content": [
				"**RBAC**: Role-Based Access Control — 役割ベースの認可制御",
				"**Role**: 特定Namespace内のリソース操作を定義",
				"**ClusterRole**: クラスター全体（全Namespace + クラスターリソース）の操作を定義",
				"**RoleBinding**: Role/ClusterRoleをユーザー/グループ/SAに紐付け（Namespace内）",
				"**ClusterRoleBinding**: ClusterRoleをクラスター全体で紐付け",
				"**verbs**: get, list, watch, create, update, patch, delete, exec（要注意）"
			],
			"layout": "default"
		},
		{
			"title": "Role・ClusterRole 設定例",
			"content": ["Podの読み取り専用ロールとClusterRoleの例"],
			"code": "# Namespace限定のRole\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-reader\n  namespace: production\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n---\n# クラスター全体のClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: node-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"nodes\"]\n  verbs: [\"get\", \"list\", \"watch\"]",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "RoleBinding・ClusterRoleBinding",
			"content": ["ユーザー・グループ・ServiceAccountへのロール紐付け"],
			"code": "# RoleBinding: Namespace内でRoleを紐付け\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-reader-binding\n  namespace: production\nsubjects:\n- kind: User\n  name: alice          # aws-authのusernameに対応\n  apiGroup: rbac.authorization.k8s.io\n- kind: Group\n  name: developers     # aws-authのgroupsに対応\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "RBAC 設計パターン — 最小権限の原則",
			"content": [
				"**開発者ロール**: 自分のNS内 Pod/Deployment読み書き、Secrets読み取り不可",
				"**CI/CDロール**: Deployment更新・Imageタグ変更のみ（広いClusterRole は付与しない）",
				"**SREロール**: 全NS読み取り + Pod exec + ログ取得（書き込みは制限）",
				"**cluster-admin禁止**: 本番環境で常用するロールにcluster-adminを付与しない",
				"**Secrets管理**: secretsリソースへの `get` verb は最小限に（認証情報漏洩リスク）",
				"→ `kubectl auth can-i --list --as <user>` で付与済み権限を確認"
			],
			"layout": "default"
		},
		{
			"title": "RBAC Audit — 権限の確認と検証",
			"content": ["現在のユーザーが実行できる操作を確認する方法"],
			"code": "# 現在のユーザーの権限を一覧表示\nkubectl auth can-i --list\n\n# 特定ユーザーとして権限確認 (管理者が実行)\nkubectl auth can-i get pods \\\n  --as=alice --namespace=production\n\n# グループとしての権限確認\nkubectl auth can-i create deployments \\\n  --as-group=developers --namespace=staging\n\n# RBAC設定の全体確認\nkubectl get clusterrolebindings \\\n  -o wide | grep cluster-admin",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "IRSA（IAM Roles for Service Accounts）の仕組み",
			"content": [
				"**課題**: PodからAWSリソース（S3, DynamoDB等）にアクセスする安全な方法",
				"**従来の問題**: EC2インスタンスプロファイル → ノード上の全Podが同じ権限を持つ",
				"**IRSA解決策**: Pod単位にIAMロールを付与（ServiceAccount経由）",
				"**仕組み**: OIDCプロバイダー → JWTトークン → STS AssumeRoleWithWebIdentity",
				"**利点**: Pod単位の最小権限、IAMレベルでの監査ログ（CloudTrail）",
				"→ 前提: EKSクラスターにOIDCプロバイダーの関連付けが必要"
			],
			"layout": "default"
		},
		{
			"title": "IRSA 認証フロー",
			"content": ["![w:880 center](assets/irsa-flow.svg)"],
			"layout": "default"
		},
		{
			"title": "IRSA セットアップ手順",
			"content": [
				"OIDCプロバイダー設定からServiceAccountアノテーションまでの完全手順"
			],
			"code": "# Step1: OIDCプロバイダーを関連付け\neksctl utils associate-iam-oidc-provider \\\n  --cluster my-cluster --approve\n\n# Step2: IAMサービスアカウントを作成\neksctl create iamserviceaccount \\\n  --name s3-reader \\\n  --namespace production \\\n  --cluster my-cluster \\\n  --attach-policy-arn \\\n    arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess \\\n  --approve",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "IRSA 設定例 — ServiceAccountのアノテーション",
			"content": ["IRSAで自動作成されるServiceAccountとPodでの使い方"],
			"code": "# 自動作成されるServiceAccount\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: s3-reader\n  namespace: production\n  annotations:\n    eks.amazonaws.com/role-arn: |\n      arn:aws:iam::123456:role/s3-reader\n---\n# PodでServiceAccountを指定\nspec:\n  serviceAccountName: s3-reader\n  containers:\n  - name: app\n    image: myapp:latest\n    # AWS_WEB_IDENTITY_TOKEN_FILE が自動設定\n    # AWS_ROLE_ARN が自動設定",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "EKS Pod Identity（新機能）",
			"content": [
				"**Pod Identity**: IRSA の次世代版（2023年11月GA）",
				"**OIDCプロバイダー設定不要**: クラスターごとのOIDC設定が不要でシンプル",
				"**eksctl不要**: AWS Console/CLI/CDKから直接設定可能",
				"**Cross-account対応**: 別アカウントのIAMロールへのAssumeRoleが容易",
				"**条件変数**: `aws:SourceCluster` でクラスター単位のポリシー制御",
				"→ 新規EKSクラスターではPod Identityの採用を推奨"
			],
			"layout": "default"
		},
		{
			"title": "Pod Identity 設定例",
			"content": ["Pod Identity Associationの作成（OIDCプロバイダー設定不要）"],
			"code": "# Pod Identity Add-onを有効化\naws eks create-addon \\\n  --cluster-name my-cluster \\\n  --addon-name eks-pod-identity-agent\n\n# Pod Identity Associationを作成\naws eks create-pod-identity-association \\\n  --cluster-name my-cluster \\\n  --namespace production \\\n  --service-account s3-reader \\\n  --role-arn arn:aws:iam::123:role/s3-reader\n\n# IAMロール信頼ポリシー\n# Principal: {\"Service\": \"pods.eks.amazonaws.com\"}",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "Pod Identity vs IRSA 比較",
			"content": [
				"| 項目 | IRSA | Pod Identity |",
				"| OIDC設定 | 必要（per cluster） | **不要** |",
				"| eksctl依存 | 高い | **低い** |",
				"| cross-account | 複雑 | **シンプル** |",
				"| 既存クラスター対応 | ✅ | ✅ |",
				"| 試験TIP | IRSA = OIDCベース | Pod Identity = 新方式 |",
				"→ 新規は Pod Identity、既存は IRSA で問題なし（移行は任意）"
			],
			"layout": "default"
		},
		{
			"title": "OIDC IdP 設定と確認",
			"content": ["OIDCプロバイダーの設定確認とIAMロール信頼ポリシーの構造"],
			"code": "# OIDCプロバイダーのURLを確認\naws eks describe-cluster \\\n  --name my-cluster \\\n  --query 'cluster.identity.oidc.issuer'\n\n# IAMロール信頼ポリシー（IRSA用）\n# \"Condition\": {\n#   \"StringEquals\": {\n#     \"<OIDC_URL>:sub\":\n#       \"system:serviceaccount:prod:s3-reader\",\n#     \"<OIDC_URL>:aud\": \"sts.amazonaws.com\"\n#   }\n# }",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "AWS SSO と EKS 統合",
			"content": [
				"**AWS SSO (IAM Identity Center)**: 複数AWSアカウントへの統合認証",
				"**EKS連携**: SSOのPermission SetからIAMロールを生成 → aws-authに登録",
				"**メリット**: 個人IAMユーザー不要・アクセス期限管理・MFA強制",
				"**手順**: SSO Login → `aws sso login` → `aws eks update-kubeconfig`",
				"**試験TIP**: 「複数アカウントのEKSに一元認証」→ SSO + aws-auth + ClusterRoleが正解",
				"→ SSO中断後はトークン期限切れでkubectlが失敗（再ログイン必要）"
			],
			"layout": "default"
		},
		{
			"title": "Multi-tenancy RBAC パターン",
			"content": [
				"**Namespace分離**: チームごとにNamespaceを作成しRoleBindingでアクセス制御",
				"**LimitRange + ResourceQuota**: Namespace単位でリソース上限を設定",
				"**NamespaceAdminロール**: 自分のNS内のDeployment/Podを全操作、他NSは不可",
				"**NetworkPolicyで補完**: RBACは APIレベル制御 → ネットワークはNetworkPolicyで",
				"**危険なverb**: `exec`, `portforward`, `proxy` は必要最小限に制限",
				"→ `kubectl create namespace <team>` + `RoleBinding` でシンプルに実現"
			],
			"layout": "default"
		},
		{
			"title": "Cluster Admin 権限の安全な管理",
			"content": [
				"**cluster-adminリスク**: 全リソースの全操作が可能 → 最高権限",
				"**Break Glass手順**: cluster-admin権限を持つ緊急アカウントを別途管理",
				"**監査**: CloudTrailでcluster-admin使用ログを監視・アラート設定",
				"**定期レビュー**: ClusterRoleBindingのsubjectsを定期的に棚卸し",
				"**サービスアカウントへの付与禁止**: `default` SAへのcluster-admin付与は厳禁",
				"→ `kubectl get clusterrolebindings | grep cluster-admin` で確認"
			],
			"layout": "default"
		},
		{
			"title": "Service Account と RBAC",
			"content": [
				"**ServiceAccount (SA)**: Pod実行時のK8sアイデンティティ（人間ではなくワークロード）",
				"**default SA問題**: Namespaceのdefault SAはRoleなしでも存在する",
				"**自動マウント無効化**: `automountServiceAccountToken: false` を設定推奨",
				"**専用SA作成**: ワークロードごとに専用SAを作成して最小権限を付与",
				"**試験TIP**: 「PodにS3アクセスさせたい」→ IRSAを使った専用SA + IAMロール",
				"→ default SAへの過剰なRoleBinding は重大なセキュリティリスク"
			],
			"layout": "default"
		},
		{
			"title": "RBAC 試験頻出ポイント 10選",
			"content": [
				"① ClusterRole + RoleBinding = 特定Namespace内でClusterRoleを使用",
				"② `exec` verb はPodへのシェル接続権限 → 最小化必須",
				"③ aws-authのmapRoles groupsが K8s RBACのGroupに対応",
				"④ IRSA = OIDC + STS → Pod単位のIAM権限",
				"⑤ Pod Identity = IRSA の後継（OIDC設定不要）",
				"⑥ `system:masters` グループ = cluster-admin相当（aws-authに追加厳禁）",
				"⑦ `kubectl auth can-i` = 権限確認コマンド"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 4: イメージセキュリティ・ECR",
			"content": [
				"コンテナイメージはサプライチェーン攻撃の主な入口",
				"ECRスキャン・署名・Admission Controlで多層防御を実現する"
			],
			"layout": "section"
		},
		{
			"title": "コンテナイメージの脅威モデル",
			"content": [
				"**既知脆弱性**: パッチ未適用のOSパッケージ・言語ライブラリの脆弱性（CVE）",
				"**マルウェア埋め込み**: 悪意あるベースイメージ・サプライチェーン汚染",
				"**秘密情報の混入**: ビルド時にSecretをLAYERに含めてしまうミス",
				"**過剰なツール**: デバッグツール（curl, wget, netcat）が攻撃者に悪用される",
				"**Latestタグ**: バージョン固定なし → 意図しないイメージ更新リスク",
				"→ 対策: 最小イメージ・スキャン・署名・Admission Controlの多層防御"
			],
			"layout": "default"
		},
		{
			"title": "イメージレイヤーとセキュリティリスク",
			"content": [
				"**レイヤー構造**: Dockerfileの各命令がレイヤーを生成（変更不可）",
				"**秘密情報漏洩**: RUN文でSecretを使うと履歴レイヤーに残る",
				"**対策**: BuildKitの `--secret` フラグでビルド時シークレットを安全に渡す",
				"**ダイジェスト固定**: `image: nginx@sha256:abc...` でイメージを固定",
				"**Scratch/Distroless**: シェル・パッケージマネージャーなし → 攻撃面最小化",
				"→ `docker history <image>` でレイヤー内容を確認可能"
			],
			"layout": "default"
		},
		{
			"title": "ECR の基本設定",
			"content": [
				"**プライベートレジストリ**: AWSアカウント単位のフルマネージドコンテナレジストリ",
				"**パブリックレジストリ**: ECR Public（Docker Hubの代替）",
				"**暗号化**: デフォルトでAES-256暗号化（KMSカスタム鍵も選択可）",
				"**プッシュ権限**: IAMポリシー（`ecr:PutImage`, `ecr:InitiateLayerUpload`等）",
				"**プル権限**: ECSタスク/EKS Pod実行ロールに `ecr:GetDownloadUrlForLayer` 等",
				"→ `aws ecr get-login-password | docker login --username AWS --password-stdin <registry>`"
			],
			"layout": "default"
		},
		{
			"title": "ECR ライフサイクルポリシー",
			"content": ["古いイメージを自動削除してリポジトリを管理するポリシー設定"],
			"code": "# ECRライフサイクルポリシー例\n{\n  \"rules\": [\n    {\n      \"rulePriority\": 1,\n      \"description\": \"最新10イメージのみ保持\",\n      \"selection\": {\n        \"tagStatus\": \"tagged\",\n        \"tagPrefixList\": [\"prod-\"],\n        \"countType\": \"imageCountMoreThan\",\n        \"countNumber\": 10\n      },\n      \"action\": {\"type\": \"expire\"}\n    }\n  ]\n}",
			"codeLanguage": "json",
			"layout": "default"
		},
		{
			"title": "ECR 基本スキャン vs 拡張スキャン",
			"content": [
				"| 項目 | 基本スキャン | 拡張スキャン（Inspector V2） |",
				"| タイミング | Pushのみ | **継続的**（CVE更新でも再スキャン） |",
				"| スコープ | OSパッケージのみ | OS + **言語パッケージ**（pip, npm等） |",
				"| 費用 | **無料** | 有料（Inspector V2料金） |",
				"| 通知 | EventBridge | EventBridge + **Security Hub** |",
				"| 推奨 | 小規模・開発環境 | **本番環境** |",
				"→ 試験TIP: 「Pythonライブラリの脆弱性を継続監視」→ 拡張スキャン"
			],
			"layout": "default"
		},
		{
			"title": "ECR 拡張スキャン（Inspector V2）設定",
			"content": ["Inspector V2を有効化してECR継続スキャンを設定する"],
			"code": "# Inspector V2を有効化（ECR拡張スキャン）\naws inspector2 enable \\\n  --resource-types ECR \\\n  --region ap-northeast-1\n\n# ECRリポジトリのスキャン設定を確認\naws ecr describe-repositories \\\n  --query 'repositories[*].imageScanningConfiguration'\n\n# スキャン結果の取得\naws ecr describe-image-scan-findings \\\n  --repository-name my-app \\\n  --image-id imageTag=latest",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "スキャン結果の解釈と優先度付け",
			"content": [
				"**CRITICAL**: 即時対応が必要（CVSS 9.0以上）",
				"**HIGH**: 早急に対応（CVSS 7.0-8.9）",
				"**MEDIUM/LOW**: 計画的に対応（CVSS 4.0-6.9 / 0.1-3.9）",
				"**Exploitability**: 実際に悪用されているCVEを優先（KEV: Known Exploited Vulnerabilities）",
				"**対策優先度**: CRITICAL + 悪用実績あり > CRITICAL > HIGH の順",
				"→ Inspector V2の「Fix available」フィルターで対処可能な脆弱性を絞り込む"
			],
			"layout": "default"
		},
		{
			"title": "イメージ署名（Notation / AWS Signer）",
			"content": [
				"**目的**: イメージが信頼された発行元のものであることを証明（改ざん検知）",
				"**Notation（OCI標準）**: CNCF Notaryプロジェクト。AWS Signerと統合",
				"**AWS Signer**: KMS管理の鍵でDockerイメージに署名",
				"**検証**: Admission Controller（Kyverno/OPA）で署名検証 → 未署名はデプロイ拒否",
				"**サプライチェーン保護**: ビルド → 署名 → 検証の一貫したパイプラインを構築",
				"→ `notation sign --key <key-id> <registry>/<repo>@<digest>` で署名"
			],
			"layout": "default"
		},
		{
			"title": "SBOM（Software Bill of Materials）",
			"content": [
				"**SBOM**: ソフトウェアの材料表 — 使用しているパッケージ・バージョンの一覧",
				"**形式**: CycloneDX（推奨）, SPDX（Linux Foundation標準）",
				"**ECR**: Inspector V2がSBOMを自動生成・管理",
				"**用途**: 新しいCVE発生時に影響するコンテナを即座に特定",
				"**生成ツール**: Syft（Anchore）, Trivy（`--format cyclonedx`）",
				"→ 「Log4Shell」のような大規模CVE発生時にSBOMで影響範囲を即日特定できた事例"
			],
			"layout": "default"
		},
		{
			"title": "OPA Gatekeeper 入門",
			"content": [
				"**OPA（Open Policy Agent）**: Rego言語でポリシーを定義するポリシーエンジン",
				"**Gatekeeper**: OPAをKubernetes Admission WebhookとしてデプロイするCRD",
				"**ConstraintTemplate**: ポリシーのテンプレート（Regoコードを含む）",
				"**Constraint**: ConstraintTemplateのインスタンス（パラメーターを指定）",
				"**Audit機能**: 既存リソースへのポリシー適用確認（デプロイ前に違反を検出）",
				"→ `gatekeeper-system` Namespaceにインストール"
			],
			"layout": "default"
		},
		{
			"title": "Kyverno Policy 設定例",
			"content": ["署名済みイメージのみデプロイを許可するKyvernoポリシー"],
			"code": "# 署名されたECRイメージのみ許可\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: verify-image-signature\nspec:\n  validationFailureAction: Enforce\n  rules:\n  - name: verify-signature\n    match:\n      resources:\n        kinds: [Pod]\n    verifyImages:\n    - imageReferences:\n      - \"123456.dkr.ecr.ap-northeast-1.amazonaws.com/*\"\n      attestors:\n      - entries:\n        - keys:\n            kms: awskms:///arn:aws:kms:...",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "ベースイメージのセキュリティ戦略",
			"content": [
				"**Alpine Linux**: 軽量（~5MB）、musl libc使用、最小パッケージ",
				"**Distroless（Google）**: シェルなし、パッケージマネージャーなし、言語ランタイムのみ",
				"**Scratch**: 完全空イメージ（静的バイナリのみ）",
				"**UBI（Red Hat）**: エンタープライズサポート付き最小イメージ",
				"**Docker Hub Officialイメージ**: 信頼性高い → ただしバージョン固定必須",
				"→ 試験TIP: 「シェルを排除してセキュリティを高める」→ Distrolessが正解"
			],
			"layout": "default"
		},
		{
			"title": "マルチステージビルドのベストプラクティス",
			"content": ["ビルド環境と実行環境を分離して最小イメージを作成する例"],
			"code": "# マルチステージビルド例（Go）\nFROM golang:1.22 AS builder\nWORKDIR /app\nCOPY . .\n# ビルド: CGO無効、静的バイナリ生成\nRUN CGO_ENABLED=0 go build -o server .\n\n# 実行ステージ: Distrolessを使用\nFROM gcr.io/distroless/static:nonroot\nWORKDIR /app\nCOPY --from=builder /app/server .\n# rootで実行しない\nUSER nonroot:nonroot\nCMD [\"/app/server\"]",
			"codeLanguage": "dockerfile",
			"layout": "default"
		},
		{
			"title": "CI/CDパイプラインへのスキャン統合",
			"content": ["![w:860 center](assets/ecr-scan-pipeline.svg)"],
			"layout": "default"
		},
		{
			"title": "ECR クロスアカウントアクセス",
			"content": ["別AWSアカウントからECRのイメージをプルする設定"],
			"code": "# ECRリポジトリポリシー（アカウントB からのプルを許可）\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::ACCOUNT_B_ID:root\"\n      },\n      \"Action\": [\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:BatchGetImage\",\n        \"ecr:BatchCheckLayerAvailability\"\n      ]\n    }\n  ]\n}",
			"codeLanguage": "json",
			"layout": "default"
		},
		{
			"title": "イメージセキュリティ 試験頻出ポイント",
			"content": [
				"① 基本スキャン=無料・Pushのみ、拡張スキャン=有料・継続・言語pkg対応",
				"② 「継続的なCVE検知」「言語ライブラリスキャン」→ Inspector V2（拡張スキャン）",
				"③ SBOM = ソフトウェア成分表 → CVE影響範囲の高速特定に使う",
				"④ Kyverno/OPA Gatekeeperは Admission Webhook → デプロイ前にポリシー適用",
				"⑤ Distrolessイメージ = シェルなし → `kubectl exec` が使えない（セキュリティ強化）",
				"⑥ イメージタグ `latest` の使用禁止 → ダイジェスト(`@sha256:...`)固定推奨"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 5: Fargateセキュリティ",
			"content": [
				"FargateはAWSが基盤を管理するサーバーレスコンテナ実行環境",
				"ノード管理不要だが、セキュリティ設定はユーザー責任が残る"
			],
			"layout": "section"
		},
		{
			"title": "Fargate アーキテクチャ（マイクロVM分離）",
			"content": [
				"**Firecracker**: AWS開発のマイクロVMM（KVMベース）",
				"**1 Pod = 1 マイクロVM**: コンテナ脱出してもホストに到達不可",
				"**カーネル分離**: 各PodがそれぞれのLinuxカーネルで動作",
				"**ハイパーバイザー分離**: VMwareやXenと同等の強力なワークロード分離",
				"**試験TIP**: 「強力な分離が必要なマルチテナント環境」→ Fargateが正解",
				"→ EC2ノードと異なりホストOSへのアクセスは完全にブロック"
			],
			"layout": "default"
		},
		{
			"title": "Fargate vs EC2ノード セキュリティ比較",
			"content": ["![w:880 center](assets/fargate-vs-ec2.svg)"],
			"layout": "default"
		},
		{
			"title": "Fargate プロファイル設定",
			"content": [
				"どのPodをFargateで実行するかを定義するFargateプロファイルの設定"
			],
			"code": "# eksctlでFargateプロファイルを作成\nexsctl create fargateprofile \\\n  --cluster my-cluster \\\n  --name fp-production \\\n  --namespace production \\\n  --labels env=prod\n\n# FargateプロファイルYAML定義\napiVersion: eksctl.io/v1alpha5\nfargateProfiles:\n  - name: fp-production\n    selectors:\n      - namespace: production\n        labels:\n          workload: serverless\n    subnets:\n      - subnet-private-1a\n      - subnet-private-1c",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "Pod実行ロール（Fargate Pod Execution Role）",
			"content": [
				"**役割**: FargateがPodを起動・実行するために使うIAMロール",
				"**最低限必要な権限**: ECRからイメージをプル、CloudWatch Logsにログ送信",
				"**ユーザーのアプリ権限**: IRSAまたはPod IdentityでServiceAccountに別途付与",
				"**試験注意点**: Pod Execution Role ≠ アプリのIAM権限（混同しやすい）",
				"→ Pod Execution Role はFargate基盤用、アプリはIRSAで別管理"
			],
			"code": "# 最小のPod Execution Roleポリシー\n# AmazonEKSFargatePodExecutionRolePolicy が必要\n# 含まれる権限:\n# ecr:GetAuthorizationToken\n# ecr:BatchCheckLayerAvailability\n# ecr:GetDownloadUrlForLayer\n# ecr:BatchGetImage\n# logs:CreateLogStream\n# logs:CreateLogGroup\n# logs:PutLogEvents",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "Fargate ENI 分離（1 Pod = 1 ENI）",
			"content": [
				"**1 Pod = 1 ENI**: 各FargatePodが専用のElastic Network Interfaceを持つ",
				"**VPCレベル分離**: Pod間通信はVPCルーティング → ネットワークSGで直接制御",
				"**Security Group**: Pod専用のSGをFargateプロファイルに付与",
				"**プライベートSubnet必須**: FargateはPrivate Subnetで実行推奨（インターネット直接接触なし）",
				"**試験TIP**: EC2ノードでSGPが必要な理由 → Fargate ではデフォルトでENI分離済み",
				"→ Fargateでは追加設定なしでPod単位のSG制御が可能"
			],
			"layout": "default"
		},
		{
			"title": "Fargate ネットワーク設計",
			"content": [
				"**Private Subnetで実行**: インターネットへの直接露出を防ぐ",
				"**NAT Gateway**: FargatePodからインターネットへのEgress（ECRプル含む）",
				"**VPC Endpoints**: ECR, CloudWatch Logs等へのプライベートアクセス（NAT GW不要）",
				"**コスト最適化**: VPC EndpointはNAT GWより通信料が安い（大量トラフィック時）",
				"→ 推奨: ECR/CloudWatch/STS VPC Endpointを設定してFargateをVPCに閉じ込める"
			],
			"layout": "default"
		},
		{
			"title": "Seccomp プロファイル（Fargate）",
			"content": [
				"FargateのPodにSeccompプロファイルを適用してシステムコールを制限する"
			],
			"code": "# FargateでSeccompを設定（RuntimeDefault推奨）\napiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  securityContext:\n    seccompProfile:\n      type: RuntimeDefault  # Fargate推奨\n  containers:\n  - name: app\n    image: myapp:1.0.0\n    securityContext:\n      runAsNonRoot: true\n      runAsUser: 1000\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Fargate のリソース制限",
			"content": [
				"**サポートするCPU**: 0.25, 0.5, 1, 2, 4, 8, 16 vCPU",
				"**サポートするメモリ**: CPUに対応した固定の組み合わせ",
				"**制限の重要性**: リソース上限なし → 他Podへの影響（Fargateは1Pod分離だが費用に影響）",
				"**requests ≠ limits問題**: Fargateはrequestsをベースにリソースを確保",
				"**GPU**: サポートなし（GPUワークロードはEC2ノードが必要）",
				"→ `resources.requests` を必ず設定 → Fargateのコスト計算に使われる"
			],
			"layout": "default"
		},
		{
			"title": "Fargate Spot とセキュリティ考慮事項",
			"content": [
				"**Fargate Spot**: 中断される可能性があるが最大70%コスト削減",
				"**中断通知**: ECS Fargate Spotは2分前に通知（EKSも同様）",
				"**セキュリティへの影響**: 中断時にデータ保護を考慮（PersistentVolumeの扱い）",
				"**本番利用**: PodDisruptionBudgetと組み合わせて可用性を確保",
				"**ステートレス推奨**: FargateSpotはステートレスワークロードに最適",
				"→ 試験TIP: 「コスト削減しつつセキュアに」→ Fargate Spot + PDB + PVC設計"
			],
			"layout": "default"
		},
		{
			"title": "Fargate ログ設定（FireLens）",
			"content": [
				"FireLensサイドカーでFargateのコンテナログをCloudWatch/S3/Firehoseに転送"
			],
			"code": "# FargateでFireLensを使ったログ設定\nspec:\n  containers:\n  - name: app\n    image: myapp:1.0.0\n    logConfiguration:\n      logDriver: awsfirelens\n      options:\n        Name: cloudwatch_logs\n        region: ap-northeast-1\n        log_group_name: /eks/fargate/app\n  - name: log-router\n    image: public.ecr.aws/aws-observability/aws-for-fluent-bit:latest\n    firelensConfiguration:\n      type: fluentbit",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Fargate 試験頻出ポイント",
			"content": [
				"① FargateはDaemonSetが使えない → Fluent Bit はサイドカー（FireLens）で対応",
				"② 1 Pod = 1 マイクロVM = 1 ENI → 強力な分離（EC2ノードより分離度が高い）",
				"③ privileged, hostNetwork, hostPID は使用不可",
				"④ Pod Execution Role はECRプル・ログ送信用（アプリのIAM権限ではない）",
				"⑤ OSパッチ・カーネル管理はAWS責任（ユーザーはアプリ・設定のみ）",
				"⑥ GPU非対応 → GPUワークロードはEC2マネージドノードグループが必要"
			],
			"layout": "default"
		},
		{
			"title": "ECS Fargate vs EKS Fargate 比較",
			"content": [
				"| 項目 | ECS Fargate | EKS Fargate |",
				"| オーケストレーター | ECS | Kubernetes |",
				"| 設定単位 | Task Definition | Pod Spec |",
				"| IAM権限 | Task Role (IRSA相当) | IRSA / Pod Identity |",
				"| ネットワーク | awsvpc モード | VPC CNI |",
				"| ログ | awslogs / FireLens | FireLens / Fluent Bit |",
				"→ 試験TIP: 「KubernetesをマネージドでサーバーレスにしたEKSで実行」→ EKS Fargate"
			],
			"layout": "default"
		},
		{
			"title": "Fargate セキュリティチェックリスト",
			"content": [
				"✅ Fargateプロファイルで対象Namespace/Labelを最小化",
				"✅ Pod Execution Roleは最小権限（ECRプル + ログ送信のみ）",
				"✅ アプリのAWSアクセスはIRSA/Pod Identityで実装",
				"✅ Private Subnetで実行 + VPC Endpoint設定",
				"✅ SecurityContext: runAsNonRoot, readOnlyRootFilesystem, allowPrivilegeEscalation: false",
				"✅ ResourcesのRequests/Limitsを明示的に設定"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 6: ネットワークセキュリティ",
			"content": [
				"EKSネットワークは多層防御で構成される",
				"L7(WAF) → L4(SG/NetworkPolicy) → L3(VPC/Subnet) の積み上げ設計"
			],
			"layout": "section"
		},
		{
			"title": "VPC CNI プラグイン（aws-node）",
			"content": [
				"**VPC CNI**: AWSが提供するEKS用ネットワークプラグイン（デフォルト）",
				"**動作**: 各PodにVPCのIPアドレスを割り当て（サブネットIPを消費）",
				"**ENI Warm Pool**: ノード上でENIを事前にアタッチ → Pod起動高速化",
				"**Network Policy**: VPC CNI v1.14以降でNetworkPolicy対応（Calico不要）",
				"**IRSA必要**: aws-nodeのIAMサービスアカウントに適切な権限を付与",
				"→ `kubectl describe daemonset aws-node -n kube-system` で状態確認"
			],
			"layout": "default"
		},
		{
			"title": "Network Policy 概要（Calico）",
			"content": [
				"**NetworkPolicy**: Kubernetes標準のL4トラフィック制御API",
				"**デフォルト**: NetworkPolicyなし = 全Pod間通信が許可",
				"**Ingress**: 受信トラフィックの制御（どこから来るか）",
				"**Egress**: 送信トラフィックの制御（どこへ行くか）",
				"**ポリシー対象**: podSelector + namespaceSelector で対象を指定",
				"**デフォルト拒否**: 空のNetworkPolicyで全通信拒否（then 必要なものだけ許可）"
			],
			"layout": "default"
		},
		{
			"title": "Network Policy 設定例",
			"content": [
				"バックエンドAPIへのアクセスをフロントエンドNamespaceのみに制限する例"
			],
			"code": "# backend NSへのIngress制限\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-frontend-only\n  namespace: backend\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: frontend\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.1.0/24  # DBサブネットのみ",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Security Groups for Pods（SGP）",
			"content": [
				"**SGP**: KubernetesネイティブのNetworkPolicyではなく、VPCのSGをPodに直接付与",
				"**用途**: RDS, ElastiCache等のAWSリソースへのアクセスをSGで制御",
				"**動作原理**: Trunk ENI（Branch ENI）を使ってPod単位のSGを実現",
				"**前提条件**: ノードに `AmazonVPCNetworkingPlugin` 権限、EC2インスタンスのENI Trunk対応",
				"**制限**: Fargateでは不要（デフォルトで1Pod=1ENI）。EC2ノード専用の機能",
				"→ 試験TIP: 「PodからRDSへのアクセスをSGで制御」→ SGP が正解"
			],
			"layout": "default"
		},
		{
			"title": "SGP 設定例",
			"content": ["PodにSecurity Groupを付与してRDSへのアクセスを制御する設定"],
			"code": "# ENI Config (per AZ)\napiVersion: crd.k8s.amazonaws.com/v1alpha1\nkind: ENIConfig\nmetadata:\n  name: ap-northeast-1a\nspec:\n  securityGroups:\n    - sg-pod-sg-id  # Pod専用のSG\n  subnet: subnet-private-1a\n---\n# Podのアノテーションでマニフェスト指定\nmetadata:\n  annotations:\n    vpc.amazonaws.com/pod-eni: \"true\"\nspec:\n  securityGroupPolicy:\n    groupIds:\n      - sg-pod-sg-id",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "SGP vs Network Policy — 使い分け",
			"content": [
				"| 比較項目 | Network Policy | SGP |",
				"| 制御レイヤー | K8s L4 | VPC L4 |",
				"| 主な用途 | Pod/NS間通信 | AWSリソースへの接続 |",
				"| RDS制御 | 間接的（CIDR） | **直接（SGルール）** |",
				"| DaemonSet必要 | Calico等 | **不要（VPCネイティブ）** |",
				"| Fargate対応 | ✅ | ❌（不要、デフォルトENI分離） |",
				"→ 試験TIP: 「Pod→RDS間のSG制御」→ SGP、「NS間通信制御」→ Network Policy"
			],
			"layout": "default"
		},
		{
			"title": "EKS プライベートエンドポイント設定",
			"content": [
				"EKS APIServerをプライベートのみにして外部からのアクセスを遮断する"
			],
			"code": "# プライベートエンドポイントのみに変更\naws eks update-cluster-config \\\n  --name my-cluster \\\n  --resources-vpc-config \\\n    endpointPublicAccess=false,\\\n    endpointPrivateAccess=true\n\n# VPN/Bastion経由でkubectl実行\naws eks update-kubeconfig \\\n  --name my-cluster \\\n  --region ap-northeast-1\n\n# プライベートエンドポイントのDNS確認\nnslookup <cluster-id>.gr7.ap-northeast-1.eks.amazonaws.com",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "AWS PrivateLink と EKS",
			"content": [
				"**PrivateLink**: VPCエンドポイント経由でAWSサービスにプライベートアクセス",
				"**EKS関連の推奨VPC Endpoint**: `ecr.api`, `ecr.dkr`, `s3`, `logs`, `sts`",
				"**効果**: Fargateのイメージプル・ログ送信がインターネット不要になる",
				"**コスト**: NAT Gatewayより通信料が安い（大量通信時）",
				"→ `aws ec2 create-vpc-endpoint --vpc-id <id> --service-name com.amazonaws.ap-northeast-1.ecr.api`"
			],
			"layout": "default"
		},
		{
			"title": "ALB Ingress Controller + WAF 設定",
			"content": [
				"EKSのIngressにALBとWAFを統合して外部トラフィックを保護する設定"
			],
			"code": "# WAF統合のIngress設定\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/scheme: internet-facing\n    alb.ingress.kubernetes.io/target-type: ip\n    alb.ingress.kubernetes.io/wafv2-acl-arn: |\n      arn:aws:wafv2:ap-northeast-1:123:...\n    alb.ingress.kubernetes.io/ssl-redirect: '443'\n    alb.ingress.kubernetes.io/listen-ports: |\n      '[{\"HTTPS\":443}]'",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "NLB 設定とセキュリティ",
			"content": [
				"**NLB（Network Load Balancer）**: L4ロードバランサー、固定IPアドレス対応",
				"**使用場面**: TCPサービス、ゲームサーバー、gRPC、固定IPが必要な場合",
				"**TLS終端**: NLBでTLSを終端（ACM証明書）または Pod まで通過（TLS Passthrough）",
				"**Source IP保持**: NLBは送信元IPを保持 → SecurityGroupでクライアントIPを制御可能",
				"→ `alb.ingress.kubernetes.io/load-balancer-attributes: access_logs.s3.enabled=true` でアクセスログ有効化"
			],
			"layout": "default"
		},
		{
			"title": "Service Mesh mTLS（App Mesh / Istio）",
			"content": [
				"**mTLS（Mutual TLS）**: Pod間通信を相互に証明書で認証・暗号化",
				"**AWS App Mesh**: AWSマネージドなEnvoyベースのサービスメッシュ",
				"**Istio**: CNCF標準。より高機能だが複雑",
				"**メリット**: NetworkPolicyを超えた通信の暗号化・可視性・サーキットブレーカー",
				"**試験TIP**: 「Pod間の通信を暗号化したい」→ mTLS（App Mesh or Istio）が正解",
				"→ EKS ではIstioよりApp MeshがAWS統合の観点で出題されやすい"
			],
			"layout": "default"
		},
		{
			"title": "DNS セキュリティ（CoreDNS設定）",
			"content": [
				"**CoreDNS**: EKSのクラスター内DNS解決を担うコンポーネント",
				"**外部DNS露出**: CoreDNSのClusterIPはVPC内からのみアクセス可能",
				"**DNSポリシー**: `dnsPolicy: None` + `dnsConfig` で特定DNSサーバーを指定",
				"**DNS exfiltration**: DNSクエリを使ったデータ流出（DNS over HTTPS等）に注意",
				"**CoreDNS設定変更**: ConfigMapで外部フォワーダーを制限",
				"→ GuardDutyのDNS検知機能でDNS異常通信を監視"
			],
			"layout": "default"
		},
		{
			"title": "Egress 制御",
			"content": [
				"**Egress制御の重要性**: 侵害されたPodがデータを外部に送信するのを防ぐ",
				"**NetworkPolicy Egress**: 特定CIDR/Namespaceへの送信のみ許可",
				"**NAT Gateway + セキュリティグループ**: Egress通信をNAT GW経由に集約してフィルタリング",
				"**Firewall Manager**: 組織全体のVPCレベルでEgress制御（Network Firewall連携）",
				"**DNS制御**: CoreDNSで名前解決を制限 → 不明ドメインへの通信を防止",
				"→ 試験TIP: 「侵害されたPodのデータ流出を防ぐ」→ NetworkPolicy Egress + NAT GW制御"
			],
			"layout": "default"
		},
		{
			"title": "ネットワークアーキテクチャ図",
			"content": ["![w:880 center](assets/network-policy-arch.svg)"],
			"layout": "default"
		},
		{
			"title": "ネットワークセキュリティ 試験頻出ポイント",
			"content": [
				"① NetworkPolicy: Namespace/Pod間のL4制御。Calicoまたは VPC CNI v1.14+が必要",
				"② SGP: PodにVPC SGを直接付与。EC2ノードでRDS/ElastiCache接続制御に最適",
				"③ ALB + WAF: L7フィルタリング、SQLi/XSS防御。IngressのAnnotationで設定",
				"④ EKS private endpoint: Bastionまたは VPN経由のkubectl接続が必要",
				"⑤ VPC Endpoint: インターネット経由せずECR/S3/CloudWatchにアクセス",
				"⑥ mTLS: Pod間通信を暗号化。App Mesh または Istioで実現"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 7: Pod・ワークロードセキュリティ",
			"content": [
				"Pod自体のセキュリティ設定・Secretsの安全な管理",
				"OPA/KyvernoによるPolicy as Codeでセキュリティを自動化する"
			],
			"layout": "section"
		},
		{
			"title": "Pod Security Standards（PSS）",
			"content": [
				"**PSS**: Kubernetes 1.25以降のPodセキュリティ標準（PodSecurityPolicy廃止の後継）",
				"**Privileged**: 制限なし（特権Pod可）",
				"**Baseline**: 既知の権限昇格を防ぐ最小制限",
				"**Restricted**: Baselineに加え、rootでの実行不可・読み取り専用FS推奨",
				"**適用方法**: Namespaceのラベルで設定 → Pod Security Admission（PSA）が強制",
				"→ 試験TIP: 「PodSecurityPolicyの後継」→ PSS/PSA が正解（1.25でPSP廃止）"
			],
			"layout": "default"
		},
		{
			"title": "Pod Security Admission（PSA）設定",
			"content": ["Namespaceのラベルで強制・警告・監査の各モードを設定する"],
			"code": "# Namespaceにrestrictedモードを適用\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    # enforce: ポリシー違反のPodを拒否\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/enforce-version: latest\n    # warn: ポリシー違反を警告（作成は可能）\n    pod-security.kubernetes.io/warn: restricted\n    # audit: 監査ログに記録\n    pod-security.kubernetes.io/audit: restricted",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "SecurityContext 設定",
			"content": ["コンテナセキュリティを高める SecurityContext の必須設定例"],
			"code": "apiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    runAsNonRoot: true      # root以外で実行\n    runAsUser: 1000\n    fsGroup: 2000\n    seccompProfile:\n      type: RuntimeDefault  # システムコール制限\n  containers:\n  - name: app\n    image: myapp:1.0.0\n    securityContext:\n      allowPrivilegeEscalation: false  # 昇格禁止\n      readOnlyRootFilesystem: true     # FS読み取り専用\n      capabilities:\n        drop: [\"ALL\"]      # 全Capabilityを削除",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Linux Capabilities 管理",
			"content": ["デフォルトCapabilityを全削除し、必要なものだけ追加する例"],
			"code": "# 全Capabilityを削除し必要なものだけ追加\nsecurityContext:\n  capabilities:\n    drop:\n      - ALL          # 全て削除\n    add:\n      - NET_BIND_SERVICE  # 1024以下ポートバインド\n\n# 危険なCapabilities（絶対に付与しない）:\n# SYS_ADMIN  - システム管理（コンテナ脱出可能）\n# NET_ADMIN  - ネットワーク設定変更\n# SYS_PTRACE - プロセストレース\n# DAC_OVERRIDE - ファイル権限バイパス",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Secrets 管理（AWS Secrets Manager 統合）",
			"content": [
				"**K8s Secrets の問題点**: Base64エンコードのみ（暗号化ではない）。etcd暗号化が必要",
				"**AWS Secrets Manager**: 完全暗号化・自動ローテーション・バージョン管理・監査ログ",
				"**統合方法①**: CSI Secrets Store Driver（ファイルとしてPodに注入）",
				"**統合方法②**: External Secrets Operator（K8s Secretsに同期）",
				"**ローテーション**: Secrets Managerの自動ローテーションがトリガー → Podの再起動不要（CSI）",
				"→ 試験TIP: 「データベースパスワードをPodに安全に渡す」→ Secrets Manager + CSI"
			],
			"layout": "default"
		},
		{
			"title": "External Secrets Operator 設定",
			"content": [
				"Secrets ManagerのシークレットをK8s Secretとして自動同期する設定"
			],
			"code": "# ExternalSecretでSecrets ManagerをK8s Secretに同期\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: db-credentials\n  namespace: production\nspec:\n  refreshInterval: 1h  # 1時間ごとに同期\n  secretStoreRef:\n    name: aws-secrets-manager\n    kind: ClusterSecretStore\n  target:\n    name: db-secret  # 生成するK8s Secret名\n  data:\n  - secretKey: password\n    remoteRef:\n      key: prod/db/password",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "CSI Secrets Store Driver 設定",
			"content": [
				"Secrets ManagerをCSI経由でPodにファイルとしてマウントする設定"
			],
			"code": "# SecretProviderClass設定\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: aws-secrets\nspec:\n  provider: aws\n  parameters:\n    objects: |\n      - objectName: \"prod/db/password\"\n        objectType: \"secretsmanager\"\n---\n# PodでCSIボリュームとしてマウント\nvolumes:\n- name: secrets\n  csi:\n    driver: secrets-store.csi.k8s.io\n    readOnly: true\n    volumeAttributes:\n      secretProviderClass: aws-secrets",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "OPA Gatekeeper ConstraintTemplate 例",
			"content": [
				"Latestタグのイメージ使用を禁止するConstraintTemplateとConstraintの例"
			],
			"code": "apiVersion: templates.gatekeeper.sh/v1\nkind: ConstraintTemplate\nmetadata:\n  name: k8sdeniedtags\nspec:\n  crd:\n    spec:\n      names:\n        kind: K8sDeniedTags\n      validation:\n        properties:\n          tags:\n            type: array\n            items: {type: string}\n  targets:\n  - target: admission.k8s.gatekeeper.sh\n    rego: |\n      package k8sdeniedtags\n      violation[{\"msg\": msg}] {\n        img := input.review.object.spec.containers[_].image\n        endswith(img, \":latest\")\n        msg := \"latest tag is not allowed\"\n      }",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "ResourceQuota / LimitRange",
			"content": ["NamespaceレベルとPodレベルのリソース制限を設定する例"],
			"code": "# Namespace全体のResourceQuota\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: production-quota\n  namespace: production\nspec:\n  hard:\n    requests.cpu: \"10\"\n    requests.memory: 20Gi\n    limits.cpu: \"20\"\n    limits.memory: 40Gi\n    pods: \"50\"\n---\n# PodのデフォルトリソースLimitRange\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: default-limits\nspec:\n  limits:\n  - type: Container\n    default:\n      cpu: 500m\n      memory: 512Mi\n    defaultRequest:\n      cpu: 100m\n      memory: 128Mi",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "Pod・ワークロードセキュリティ チェックリスト",
			"content": [
				"✅ PSA: Namespace に `restricted` または `baseline` ラベルを設定",
				"✅ runAsNonRoot: true / runAsUser: 非0 / fsGroup 設定",
				"✅ allowPrivilegeEscalation: false / readOnlyRootFilesystem: true",
				"✅ capabilities: drop ALL → 必要なもののみ add",
				"✅ Secrets: K8s Secret の直接利用より Secrets Manager CSI/ESO を優先",
				"✅ ResourceQuota + LimitRange でリソース枯渇攻撃を防止"
			],
			"layout": "default"
		},
		{
			"title": "Pod・ワークロードセキュリティ 試験頻出ポイント",
			"content": [
				"① PSP（PodSecurityPolicy）は廃止（K8s 1.25）→ PSS + PSA が後継",
				"② `readOnlyRootFilesystem: true` → 実行ファイル改ざん防止（エフェメラルVolumeは別途）",
				"③ `runAsNonRoot: true` だけでは不足 → `runAsUser` も明示的に指定する",
				"④ K8s SecretはBase64エンコードのみ → 保護にはetcd暗号化 + Secrets Manager",
				"⑤ OPA Gatekeeper と Kyverno はどちらも Admission Webhook（併用は非推奨）",
				"⑥ `automountServiceAccountToken: false` → 不要なPodのK8s API権限を排除"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 8: ランタイム監視・監査",
			"content": [
				"デプロイ後の継続的な監視・異常検知・インシデント対応が重要",
				"GuardDuty・Falco・CloudTrailで多層的な検知を実現する"
			],
			"layout": "section"
		},
		{
			"title": "EKS Control Plane ログ（CloudWatch）",
			"content": ["EKS Control PlaneのログをCloudWatch Logsに送信する設定"],
			"code": "# EKS Control Plane ログを有効化\naws eks update-cluster-config \\\n  --name my-cluster \\\n  --logging \\\n    '{\n      \"clusterLogging\": [\n        {\n          \"types\": [\n            \"api\",        # API Serverリクエスト\n            \"audit\",      # 全APIコールの監査ログ\n            \"authenticator\",# IAM認証ログ\n            \"controllerManager\",\n            \"scheduler\"\n          ],\n          \"enabled\": true\n        }\n      ]\n    }'",
			"codeLanguage": "bash",
			"layout": "default"
		},
		{
			"title": "GuardDuty EKS Protection 概要",
			"content": [
				"**EKS Audit Log Monitoring**: EKS APIサーバーの監査ログを分析して脅威を検知",
				"**Runtime Monitoring**: コンテナ内の実際のプロセス・ファイル・ネットワーク活動を監視",
				"**エージェント**: Runtime MonitoringはEKS Add-on（aws-guardduty-agent）が必要",
				"**脅威インテリジェンス**: AWSの脅威インテリジェンスと機械学習で分析",
				"**コスト**: Audit Log Monitoringは処理量ベース。Runtime Monitoringはノード/FargateVCPUベース",
				"→ 有効化後は追加設定不要でEKS監査ログが自動収集・分析される"
			],
			"layout": "default"
		},
		{
			"title": "GuardDuty EKS 検知カテゴリマップ",
			"content": ["![w:880 center](assets/guardduty-eks-map.svg)"],
			"layout": "default"
		},
		{
			"title": "Amazon Detective（EKS調査）",
			"content": [
				"**Amazon Detective**: GuardDuty検知後の詳細調査・原因分析を支援",
				"**EKS統合**: GuardDutyのEKS検知をDetectiveでグラフ分析",
				"**調査フロー**: GuardDuty Finding → Detective → 関連リソース・タイムライン可視化",
				"**自動収集**: VPC Flow Logs, CloudTrail, EKS Audit Logsを自動収集・相関分析",
				"**試験TIP**: 「GuardDutyの検知を深く調査したい」→ Amazon Detectiveが正解",
				"→ GuardDuty + Detective + Security Hub の組み合わせを試験で選択"
			],
			"layout": "default"
		},
		{
			"title": "Falco（ランタイム脅威検知）",
			"content": [
				"**Falco**: CNCF標準のOSSランタイムセキュリティツール（eBPF/カーネルモジュール）",
				"**検知対象**: システムコール・Kubernetes Auditイベントをリアルタイム分析",
				"**デプロイ**: DaemonSetとして全ノードにデプロイ（Fargateでは制限あり）",
				"**検知例**: `kubectl exec` の実行、`/etc/passwd` の読み取り、シェル起動、outbound接続",
				"**出力先**: stdout, syslog, gRPC, SNS, Slack等にアラートを送信",
				"→ GuardDuty Runtime Monitoring と Falco は補完関係（Falcoの方が細かいルール設定が可能）"
			],
			"layout": "default"
		},
		{
			"title": "Falco ルール設定例",
			"content": [
				"コンテナ内でのシェル起動とパスワードファイルアクセスを検知するFalcoルール"
			],
			"code": "# Falco カスタムルール例\n- rule: Shell spawned in container\n  desc: コンテナ内でシェルが起動された\n  condition: >\n    spawned_process\n    and container\n    and not container.image.repository in (trusted_images)\n    and proc.name in (shell_binaries)\n  output: >\n    Shell spawned (user=%user.name container=%container.name\n    image=%container.image.repository)\n  priority: WARNING\n  tags: [container, shell, mitre_execution]\n\n- rule: Read sensitive file in container\n  condition: open_read and container\n    and fd.name in (sensitive_files)\n  output: \"Sensitive file read: %fd.name\"\n  priority: ERROR",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "kube-bench（CIS Benchmark 自動チェック）",
			"content": [
				"kube-benchをJobとして実行してEKSのCIS Benchmark準拠を確認する"
			],
			"code": "# kube-benchをJobとして実行\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: kube-bench\nspec:\n  template:\n    spec:\n      hostPID: true\n      containers:\n      - name: kube-bench\n        image: aquasec/kube-bench:latest\n        command: [\"kube-bench\", \"--benchmark\", \"eks-1.4.0\"]\n        volumeMounts:\n        - name: var-lib-kubelet\n          mountPath: /var/lib/kubelet\n          readOnly: true\n      restartPolicy: Never",
			"codeLanguage": "yaml",
			"layout": "default"
		},
		{
			"title": "SIEM 統合（Security Hub 連携）",
			"content": [
				"**Security Hub**: AWSサービスからのセキュリティ検知を一元管理するダッシュボード",
				"**統合サービス**: GuardDuty, Inspector, Macie, Audit Manager, Firewall Manager",
				"**EKS関連**: GuardDuty EKS検知 → Security Hub → EventBridge → Lambda/SNS",
				"**SIEM転送**: Security Hub → EventBridge → Kinesis Firehose → S3 → Splunk/Datadog",
				"**コンプライアンス**: AWS Foundational Security Best Practices (FSBP) スコアを可視化",
				"→ 試験TIP: 「複数AWSアカウントのセキュリティを一元管理」→ Security Hub + Organizations"
			],
			"layout": "default"
		},
		{
			"title": "コンテナインシデント対応フロー",
			"content": [
				"**検知**: GuardDuty/Falco が異常を検知 → EventBridge でアラート",
				"**封じ込め**: 侵害Podをネットワーク分離（NetworkPolicyで通信遮断）",
				"**フォレンジック**: `kubectl exec` で侵害Pod内を調査（または `/proc` ダンプ）",
				"**Pod強制終了**: `kubectl delete pod <name> --grace-period=0` で即時削除",
				"**ノード隔離**: 侵害ノードを `kubectl cordon` でスケジュール停止 → 新Podを投入しない",
				"→ 事後: EKS Audit Logsと GuardDuty Findingsで根本原因を分析"
			],
			"layout": "default"
		},
		{
			"title": "監視・監査 チェックリスト",
			"content": [
				"✅ EKS Control Plane ログ: api, audit, authenticator を最低限有効化",
				"✅ GuardDuty EKS Audit Log Monitoring を全リージョンで有効化",
				"✅ GuardDuty Runtime Monitoring: eks-pod-identity-agentをAdd-onで追加",
				"✅ CloudTrail: 全リージョンで有効化（EKS API Callを記録）",
				"✅ Security Hub: GuardDuty統合を有効化・コンプライアンス基準を選択",
				"✅ kube-bench を定期Job として実行してCIS Benchmark準拠を確認"
			],
			"layout": "default"
		},
		{
			"title": "ランタイムセキュリティ 試験頻出ポイント",
			"content": [
				"① 「EKSクラスターの異常なAPIコールを検知」→ GuardDuty EKS Audit Log Monitoring",
				"② 「コンテナ内のプロセス活動を検知」→ GuardDuty Runtime Monitoring または Falco",
				"③ 「GuardDuty検知の詳細調査」→ Amazon Detective",
				"④ 「複数AWSサービスのセキュリティを一元管理」→ Security Hub",
				"⑤ 「CIS Benchmark準拠を自動チェック」→ kube-bench",
				"⑥ DaemonSet（Falco）はFargateで動作しない → EC2ノードまたはサイドカー方式"
			],
			"layout": "default"
		},
		{
			"title": "Chapter 9: 試験対策・頻出パターン・まとめ",
			"content": [
				"SCS-C02 / DOP-C02 の頻出パターンと試験攻略のポイントを集約",
				"実際の試験問題パターンから正解を導くフレームワーク"
			],
			"layout": "section"
		},
		{
			"title": "試験ドメイン対応マップ",
			"content": ["![w:880 center](assets/exam-domain-map.svg)"],
			"layout": "default"
		},
		{
			"title": "DevOps Pro 頻出問題パターン Top 5",
			"content": [
				"**P1**: CI/CDパイプラインでのECRスキャン → 「CRITICAL検出でデプロイブロック」",
				"**P2**: IaCでのEKSセキュリティ設定 → eksctl/Terraform でプライベートエンドポイント",
				"**P3**: EKSアップグレード自動化 → CodePipeline + eksctl でコントロールプレーン→ノード順",
				"**P4**: コンテナログの収集 → CloudWatch Container Insights + Fluent Bit DaemonSet",
				"**P5**: GitOpsによるセキュリティポリシー管理 → OPA/KyvernoポリシーをGitで管理"
			],
			"layout": "default"
		},
		{
			"title": "SCS-C02 頻出問題パターン Top 5",
			"content": [
				"**P1**: Podに最小権限でS3アクセス → IRSAまたはPod Identity（インスタンスプロファイルは不正解）",
				"**P2**: 「PodからRDSへのアクセスをSGで制御」→ SGP（Network Policyは不正解）",
				"**P3**: 「コンテナの実行時異常を検知」→ GuardDuty Runtime MonitoringまたはFalco",
				"**P4**: 「最強のPod分離が必要」→ Fargate（マイクロVM分離）",
				"**P5**: 「Podがルートで実行されないようにする」→ PSA restricted + runAsNonRoot: true"
			],
			"layout": "default"
		},
		{
			"title": "よくある落とし穴（ひっかけ問題）",
			"content": [
				"❌ 「KubernetesのSecretは暗号化されている」→ ✅ Base64エンコードのみ（etcd暗号化必要）",
				"❌ 「FargateでDaemonSetが使える」→ ✅ 使えない（Fluent Bitはサイドカー）",
				"❌ 「IRSA設定にOIDCプロバイダー不要」→ ✅ IRSAはOIDC設定必須（Pod Identityは不要）",
				"❌ 「cluster-admin RoleをDevelopersに付与」→ ✅ 最小権限のRole/ClusterRoleを作成",
				"❌ 「ECR基本スキャンで言語パッケージも検査できる」→ ✅ 言語pkgはInspector V2（拡張）"
			],
			"layout": "default"
		},
		{
			"title": "RBAC vs IAM — どちらを使うか",
			"content": [
				"**Kubernetes リソース操作**（Pod, Deployment等）→ **RBAC** を使う",
				"**AWS リソースアクセス**（S3, DynamoDB等）→ **IAM（IRSA/Pod Identity）** を使う",
				"**EKSクラスターへのkubectl接続**→ **IAM認証 + aws-auth + RBAC** の組み合わせ",
				"**ノードの起動権限**→ **EC2インスタンスプロファイル**（IAM）",
				"**試験TIP**: 「誰が何にアクセスするか」で RBAC（K8s内） vs IAM（AWS）を判断",
				"→ RBAC と IAM は独立 → 両方正しく設定しないと意図した動作にならない"
			],
			"layout": "default"
		},
		{
			"title": "セキュリティサービス選択フロー",
			"content": [
				"**脅威検知**: GuardDuty（EKS Audit + Runtime）→ Detective（深掘り調査）",
				"**イメージ脆弱性**: ECR拡張スキャン（Inspector V2）→ 継続スキャン",
				"**ポリシー強制**: OPA Gatekeeper または Kyverno → Admission Control",
				"**Secrets管理**: Secrets Manager + CSI または External Secrets Operator",
				"**ネットワーク制御**: WAF（L7）→ SGP（L4 AWS）→ NetworkPolicy（L4 K8s）",
				"**監査・コンプライアンス**: CloudTrail + Config + kube-bench + Security Hub"
			],
			"layout": "default"
		},
		{
			"title": "参考リソース・公式ドキュメント",
			"content": [
				"**AWS公式**: [EKS Best Practices Guide](https://aws.github.io/aws-eks-best-practices/security/docs/)",
				"**AWS公式**: [EKS User Guide](https://docs.aws.amazon.com/eks/latest/userguide/)",
				"**CIS Benchmark**: [CIS Amazon EKS Benchmark](https://www.cisecurity.org/benchmark/kubernetes)",
				"**CNCF**: [Falco Project](https://falco.org/), [OPA Gatekeeper](https://open-policy-agent.github.io/gatekeeper/)",
				"**試験ガイド**: [SCS-C02 Exam Guide](https://aws.amazon.com/certification/certified-security-specialty/)",
				"**試験ガイド**: [DOP-C02 Exam Guide](https://aws.amazon.com/certification/certified-devops-engineer-professional/)"
			],
			"layout": "default"
		},
		{
			"title": "まとめ — EKS セキュリティ 完全マスター",
			"content": [
				"✅ **RBAC + IRSA/Pod Identity** で認証・認可の最小権限を実現",
				"✅ **ECR拡張スキャン + OPA/Kyverno** でイメージサプライチェーンを保護",
				"✅ **Fargate** でインフラ管理を排除・強力なPod分離を実現",
				"✅ **NetworkPolicy + SGP + WAF** でネットワーク多層防御を構築",
				"✅ **GuardDuty EKS + Falco + Security Hub** で継続的な脅威監視",
				"→ 「セキュリティは後付けではなく設計から」— DevSecOps の実践"
			],
			"layout": "center"
		}
	]
}
